<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pdffactory.pdffactory API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pdffactory.pdffactory</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import tempfile
from pathlib import Path
from typing import BinaryIO, Union
import warnings
import PyPDF2
from matplotlib import pyplot as plt
from matplotlib.backends import backend_pdf as pltpdf

from tablewriter import TableWriter


# noinspection PyUnresolvedReferences
def unlink_if_exists(path: Union[Path, &#34;TransparentPath&#34;]) -&gt; None:
    &#34;&#34;&#34;Removes the file if it exists.

    Else, does nothing.
    &#34;&#34;&#34;
    if path.is_file():
        path.unlink()


class PdfFactory(object):
    &#34;&#34;&#34;A class to update and/or create a pdf object, and add pages to it. For now only matplotlib.figure and
    tablewriter.TableWriter objects can be added.

    Can be opened at the beginning of a long code to add pages from different functions. Will create a file in the
    tmp directory were pages are added, and will modify the true file when the update() method is called. update() is
    called each time and add_*() method is called. This can be prevented by passing the argument update=False to
    those method. In that case, the user will have to call the update() method later. This can save computation time
    if a lot of pages are added during the execution of the code.

    The output file is recreated by default when update() is called for the first time. This can be switched off by
    calling will_recreate(False) before adding anything to the Pdf object. In that case, pages are appended to the
    already existing file.


    The tmp file is deleted after update() finishes, and is recreated later if need be. The tmp file might not be
    deleted if the program stops abruptly.

    Examples
    --------

    &gt;&gt;&gt; # noinspection PyShadowingNames
    &gt;&gt;&gt; import matplotlib.pyplot as plt  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; from pdffactory import PdfFactory  # doctest: +SKIP

    &gt;&gt;&gt; # Also accepts remote TransparentPath objects
    &gt;&gt;&gt; pdf = PdfFactory(&#34;test.pdf&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; pdf.will_recreate(False)  # doctest: +SKIP
    &gt;&gt;&gt; plt.plot([1, 2, 3], [1, 4, 9])  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],[4, 5, 6]], index = [&#34;b&#34;, &#34;a&#34;])  # doctest: +SKIP
    &gt;&gt;&gt; tb = TableWriter(data=df)  # doctest: +SKIP
    &gt;&gt;&gt; pdf.add_figure(plt.gcf())  # doctest: +SKIP
    &gt;&gt;&gt; pdf.add_table(tb)  # doctest: +SKIP
    &#34;&#34;&#34;

    SILENCED = True
    logger = None

    @classmethod
    def set_silenced(cls, silenced: bool) -&gt; None:
        &#34;&#34;&#34;To not print anything (except errors)&#34;&#34;&#34;
        cls.SILENCED = silenced

    # noinspection PyUnresolvedReferences
    def __init__(
        self, path: Union[str, Path, &#34;TransparentPath&#34;],
    ):
        &#34;&#34;&#34;

        Parameters
        ----------
        path: Union[str, Path, &#34;TransparentPath&#34;] : Were the pdf file will be (or is) stored.
            Initialisation does not touch the file located at path.
        &#34;&#34;&#34;

        if type(path) == str:
            path = Path(path)
        self.path = path
        self.recreated = False
        self.path_tmp = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.pdf&#34;)

        PdfFactory.log(f&#34;created tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        PdfFactory.log(f&#34;test existence of tmp file : {Path(self.path_tmp.name).is_file()}&#34;, &#34;debug&#34;)

    def __del__(self):
        PdfFactory.log(f&#34;deleting tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        unlink_if_exists(Path(self.path_tmp.name, fs=&#34;local&#34;))

    def will_recreate(self, b: bool = True) -&gt; None:
        &#34;&#34;&#34;If True (default behavior), previous file is overwriten. Else,
        appends the new pages to it.

        Parameters
        ----------
        b: bool
            Default True
        &#34;&#34;&#34;
        self.recreated = not b

    def add_figure(self, fig: plt.figure, update: bool = True, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

        Parameters
        ----------
        fig: plt.figure : the figure object to add
        update: bool
            If true, updates the file located at self.path. If False,
            update must be done later by calling update() or by
            calling any add_something() method with update=True.
            Default True.
        recreate: bool :
            If True, any file found at self.path will be overwritten.
            Only valid if update is True.
            Default False.
        &#34;&#34;&#34;

        if not isinstance(fig, plt.Figure):
            raise ValueError(f&#34;Only accepts matplotlib.figure.Figure object, not {type(fig)}&#34;)

        PdfFactory.log(&#34;Adding a figure&#34;, &#34;debug&#34;)
        pdf = pltpdf.PdfPages(self.path_tmp.name)
        pdf.savefig(fig, bbox_inches=&#34;tight&#34;)
        pdf.close()
        if update:
            # If recreate is specified, recreates the file.
            # If it is the first time that add_something() was called, also
            # recreated the file
            self.update(recreate or not self.recreated)
            self.recreated = True

    def add_table(self, table: TableWriter, update: bool = True, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

        Parameters
        ----------
        table: TableWriter : the table object to add
        update: bool
            If true, updates the file located at self.path. If False,
            update must be done later by calling update() or by
            calling any add_something() method with update=True.
            Default True.
        recreate: bool :
            If True, any file found at self.path will be overwritten.
            Only valid if update is True.
            Default False.
        &#34;&#34;&#34;

        if not isinstance(table, TableWriter):
            raise ValueError(f&#34;Only accepts TableWriter object, not {type(table)}&#34;)

        PdfFactory.log(&#34;Adding a table&#34;, &#34;debug&#34;)
        table.path = self.path_tmp.name
        table.compile(silenced=PdfFactory.SILENCED, clean_tex=True)
        if update:
            # If recreate is specified, recreates the file.
            # If it is the first time that add_something() was called, also
            # recreated the file
            self.update(recreate or not self.recreated)
            self.recreated = True

    # noinspection PyBroadException,PyUnresolvedReferences
    def get_pdf_pages(
        self, path: Union[Path, &#34;TransparentPath&#34;, str], out: PyPDF2.PdfFileWriter
    ) -&gt; Union[BinaryIO, None]:
        &#34;&#34;&#34;To get existing pages in a given pdf file.

        Will raise an error if the file exists by failed to read.

        Parameters
        ----------
        path: Union[Path, TransparentPath, str] : The path to read pages from
        out: PyPDF2.PdfFileWriter :
         The object in which to store those pages

        Returns
        -------
        Union[BinaryIO, None]
            The opened file at path if successfully read, None if no
            file were found.
        &#34;&#34;&#34;

        if type(path) == str:
            path = Path(path)
        PdfFactory.log(f&#34;  getting pdf pages from {path}&#34;, &#34;debug&#34;)
        if path.is_file():
            PdfFactory.log(f&#34;    found the file {path}&#34;, &#34;debug&#34;)
            try:
                f = open(path, &#34;rb&#34;)
                pdf = PyPDF2.PdfFileReader(f)
                for ipage in range(pdf.getNumPages()):
                    out.addPage(pdf.getPage(ipage))
                return f
            except Exception as e:
                Path(self.path_tmp.name).unlink()
                raise e

        PdfFactory.log(f&#34;    did not find the file {path}&#34;, &#34;debug&#34;)
        return None

    def update(self, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;Updates the file located at self.path. Will overwrite any existing
        file at self.path if recreate is True.

        Parameters
        ----------
        recreate: bool : Overwrite any existing file at self.path if True.
            Else, update it with the new pages.
            Default False.
        &#34;&#34;&#34;

        output = PyPDF2.PdfFileWriter()

        f_old = None
        if not recreate:

            PdfFactory.log(f&#34;fetching old file {self.path}&#34;, &#34;debug&#34;)
            f_old = self.get_pdf_pages(self.path, output)

        PdfFactory.log(f&#34;fetching tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        f_new = self.get_pdf_pages(Path(self.path_tmp.name, fs=&#34;local&#34;), output)

        if &#34;append&#34; in dir(self.path):
            with open(self.path.append(&#34;_&#34;), &#34;wb&#34;) as outputStream:
                output.write(outputStream)
        else:
            with open(str(self.path) + &#34;_&#34;, &#34;wb&#34;) as outputStream:
                output.write(outputStream)

        if f_old is not None:
            f_old.close()
        if f_new is not None:
            f_new.close()

        self.path_tmp.close()

        PdfFactory.log(f&#34;deleting tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        unlink_if_exists(Path(self.path_tmp.name, fs=&#34;local&#34;))
        if &#34;append&#34; in dir(self.path):
            self.path.append(&#34;_&#34;).mv(self.path)
        else:
            Path(str(self.path) + &#34;_&#34;).rename(self.path)

    @classmethod
    def log(cls, message, type_):
        if cls.logger is None:
            if type_ == &#34;error&#34; or type_ == &#34;critical&#34;:
                if isinstance(message, BaseException):
                    raise message
                else:
                    raise ValueError(message)
            elif type_ == &#34;warning&#34;:
                warnings.warn(message)
            elif type_ != &#34;debug&#34;:
                print(message)
        else:
            getattr(cls.logger, type_)(message)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pdffactory.pdffactory.unlink_if_exists"><code class="name flex">
<span>def <span class="ident">unlink_if_exists</span></span>(<span>path: Union[pathlib.Path, ForwardRef('TransparentPath')])</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the file if it exists.</p>
<p>Else, does nothing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlink_if_exists(path: Union[Path, &#34;TransparentPath&#34;]) -&gt; None:
    &#34;&#34;&#34;Removes the file if it exists.

    Else, does nothing.
    &#34;&#34;&#34;
    if path.is_file():
        path.unlink()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pdffactory.pdffactory.PdfFactory"><code class="flex name class">
<span>class <span class="ident">PdfFactory</span></span>
<span>(</span><span>path: Union[str, pathlib.Path, ForwardRef('TransparentPath')])</span>
</code></dt>
<dd>
<div class="desc"><p>A class to update and/or create a pdf object, and add pages to it. For now only matplotlib.figure and
tablewriter.TableWriter objects can be added.</p>
<p>Can be opened at the beginning of a long code to add pages from different functions. Will create a file in the
tmp directory were pages are added, and will modify the true file when the update() method is called. update() is
called each time and add_*() method is called. This can be prevented by passing the argument update=False to
those method. In that case, the user will have to call the update() method later. This can save computation time
if a lot of pages are added during the execution of the code.</p>
<p>The output file is recreated by default when update() is called for the first time. This can be switched off by
calling will_recreate(False) before adding anything to the Pdf object. In that case, pages are appended to the
already existing file.</p>
<p>The tmp file is deleted after update() finishes, and is recreated later if need be. The tmp file might not be
deleted if the program stops abruptly.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # noinspection PyShadowingNames
&gt;&gt;&gt; import matplotlib.pyplot as plt  # doctest: +SKIP
&gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
&gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
&gt;&gt;&gt; from pdffactory import PdfFactory  # doctest: +SKIP
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Also accepts remote TransparentPath objects
&gt;&gt;&gt; pdf = PdfFactory(&quot;test.pdf&quot;)  # doctest: +SKIP
&gt;&gt;&gt; pdf.will_recreate(False)  # doctest: +SKIP
&gt;&gt;&gt; plt.plot([1, 2, 3], [1, 4, 9])  # doctest: +SKIP
&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],[4, 5, 6]], index = [&quot;b&quot;, &quot;a&quot;])  # doctest: +SKIP
&gt;&gt;&gt; tb = TableWriter(data=df)  # doctest: +SKIP
&gt;&gt;&gt; pdf.add_figure(plt.gcf())  # doctest: +SKIP
&gt;&gt;&gt; pdf.add_table(tb)  # doctest: +SKIP
</code></pre>
<h2 id="parameters">Parameters</h2>
<p>path: Union[str, Path, "TransparentPath"] : Were the pdf file will be (or is) stored.
Initialisation does not touch the file located at path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdfFactory(object):
    &#34;&#34;&#34;A class to update and/or create a pdf object, and add pages to it. For now only matplotlib.figure and
    tablewriter.TableWriter objects can be added.

    Can be opened at the beginning of a long code to add pages from different functions. Will create a file in the
    tmp directory were pages are added, and will modify the true file when the update() method is called. update() is
    called each time and add_*() method is called. This can be prevented by passing the argument update=False to
    those method. In that case, the user will have to call the update() method later. This can save computation time
    if a lot of pages are added during the execution of the code.

    The output file is recreated by default when update() is called for the first time. This can be switched off by
    calling will_recreate(False) before adding anything to the Pdf object. In that case, pages are appended to the
    already existing file.


    The tmp file is deleted after update() finishes, and is recreated later if need be. The tmp file might not be
    deleted if the program stops abruptly.

    Examples
    --------

    &gt;&gt;&gt; # noinspection PyShadowingNames
    &gt;&gt;&gt; import matplotlib.pyplot as plt  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; from pdffactory import PdfFactory  # doctest: +SKIP

    &gt;&gt;&gt; # Also accepts remote TransparentPath objects
    &gt;&gt;&gt; pdf = PdfFactory(&#34;test.pdf&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; pdf.will_recreate(False)  # doctest: +SKIP
    &gt;&gt;&gt; plt.plot([1, 2, 3], [1, 4, 9])  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],[4, 5, 6]], index = [&#34;b&#34;, &#34;a&#34;])  # doctest: +SKIP
    &gt;&gt;&gt; tb = TableWriter(data=df)  # doctest: +SKIP
    &gt;&gt;&gt; pdf.add_figure(plt.gcf())  # doctest: +SKIP
    &gt;&gt;&gt; pdf.add_table(tb)  # doctest: +SKIP
    &#34;&#34;&#34;

    SILENCED = True
    logger = None

    @classmethod
    def set_silenced(cls, silenced: bool) -&gt; None:
        &#34;&#34;&#34;To not print anything (except errors)&#34;&#34;&#34;
        cls.SILENCED = silenced

    # noinspection PyUnresolvedReferences
    def __init__(
        self, path: Union[str, Path, &#34;TransparentPath&#34;],
    ):
        &#34;&#34;&#34;

        Parameters
        ----------
        path: Union[str, Path, &#34;TransparentPath&#34;] : Were the pdf file will be (or is) stored.
            Initialisation does not touch the file located at path.
        &#34;&#34;&#34;

        if type(path) == str:
            path = Path(path)
        self.path = path
        self.recreated = False
        self.path_tmp = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.pdf&#34;)

        PdfFactory.log(f&#34;created tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        PdfFactory.log(f&#34;test existence of tmp file : {Path(self.path_tmp.name).is_file()}&#34;, &#34;debug&#34;)

    def __del__(self):
        PdfFactory.log(f&#34;deleting tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        unlink_if_exists(Path(self.path_tmp.name, fs=&#34;local&#34;))

    def will_recreate(self, b: bool = True) -&gt; None:
        &#34;&#34;&#34;If True (default behavior), previous file is overwriten. Else,
        appends the new pages to it.

        Parameters
        ----------
        b: bool
            Default True
        &#34;&#34;&#34;
        self.recreated = not b

    def add_figure(self, fig: plt.figure, update: bool = True, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

        Parameters
        ----------
        fig: plt.figure : the figure object to add
        update: bool
            If true, updates the file located at self.path. If False,
            update must be done later by calling update() or by
            calling any add_something() method with update=True.
            Default True.
        recreate: bool :
            If True, any file found at self.path will be overwritten.
            Only valid if update is True.
            Default False.
        &#34;&#34;&#34;

        if not isinstance(fig, plt.Figure):
            raise ValueError(f&#34;Only accepts matplotlib.figure.Figure object, not {type(fig)}&#34;)

        PdfFactory.log(&#34;Adding a figure&#34;, &#34;debug&#34;)
        pdf = pltpdf.PdfPages(self.path_tmp.name)
        pdf.savefig(fig, bbox_inches=&#34;tight&#34;)
        pdf.close()
        if update:
            # If recreate is specified, recreates the file.
            # If it is the first time that add_something() was called, also
            # recreated the file
            self.update(recreate or not self.recreated)
            self.recreated = True

    def add_table(self, table: TableWriter, update: bool = True, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

        Parameters
        ----------
        table: TableWriter : the table object to add
        update: bool
            If true, updates the file located at self.path. If False,
            update must be done later by calling update() or by
            calling any add_something() method with update=True.
            Default True.
        recreate: bool :
            If True, any file found at self.path will be overwritten.
            Only valid if update is True.
            Default False.
        &#34;&#34;&#34;

        if not isinstance(table, TableWriter):
            raise ValueError(f&#34;Only accepts TableWriter object, not {type(table)}&#34;)

        PdfFactory.log(&#34;Adding a table&#34;, &#34;debug&#34;)
        table.path = self.path_tmp.name
        table.compile(silenced=PdfFactory.SILENCED, clean_tex=True)
        if update:
            # If recreate is specified, recreates the file.
            # If it is the first time that add_something() was called, also
            # recreated the file
            self.update(recreate or not self.recreated)
            self.recreated = True

    # noinspection PyBroadException,PyUnresolvedReferences
    def get_pdf_pages(
        self, path: Union[Path, &#34;TransparentPath&#34;, str], out: PyPDF2.PdfFileWriter
    ) -&gt; Union[BinaryIO, None]:
        &#34;&#34;&#34;To get existing pages in a given pdf file.

        Will raise an error if the file exists by failed to read.

        Parameters
        ----------
        path: Union[Path, TransparentPath, str] : The path to read pages from
        out: PyPDF2.PdfFileWriter :
         The object in which to store those pages

        Returns
        -------
        Union[BinaryIO, None]
            The opened file at path if successfully read, None if no
            file were found.
        &#34;&#34;&#34;

        if type(path) == str:
            path = Path(path)
        PdfFactory.log(f&#34;  getting pdf pages from {path}&#34;, &#34;debug&#34;)
        if path.is_file():
            PdfFactory.log(f&#34;    found the file {path}&#34;, &#34;debug&#34;)
            try:
                f = open(path, &#34;rb&#34;)
                pdf = PyPDF2.PdfFileReader(f)
                for ipage in range(pdf.getNumPages()):
                    out.addPage(pdf.getPage(ipage))
                return f
            except Exception as e:
                Path(self.path_tmp.name).unlink()
                raise e

        PdfFactory.log(f&#34;    did not find the file {path}&#34;, &#34;debug&#34;)
        return None

    def update(self, recreate: bool = False) -&gt; None:
        &#34;&#34;&#34;Updates the file located at self.path. Will overwrite any existing
        file at self.path if recreate is True.

        Parameters
        ----------
        recreate: bool : Overwrite any existing file at self.path if True.
            Else, update it with the new pages.
            Default False.
        &#34;&#34;&#34;

        output = PyPDF2.PdfFileWriter()

        f_old = None
        if not recreate:

            PdfFactory.log(f&#34;fetching old file {self.path}&#34;, &#34;debug&#34;)
            f_old = self.get_pdf_pages(self.path, output)

        PdfFactory.log(f&#34;fetching tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        f_new = self.get_pdf_pages(Path(self.path_tmp.name, fs=&#34;local&#34;), output)

        if &#34;append&#34; in dir(self.path):
            with open(self.path.append(&#34;_&#34;), &#34;wb&#34;) as outputStream:
                output.write(outputStream)
        else:
            with open(str(self.path) + &#34;_&#34;, &#34;wb&#34;) as outputStream:
                output.write(outputStream)

        if f_old is not None:
            f_old.close()
        if f_new is not None:
            f_new.close()

        self.path_tmp.close()

        PdfFactory.log(f&#34;deleting tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
        unlink_if_exists(Path(self.path_tmp.name, fs=&#34;local&#34;))
        if &#34;append&#34; in dir(self.path):
            self.path.append(&#34;_&#34;).mv(self.path)
        else:
            Path(str(self.path) + &#34;_&#34;).rename(self.path)

    @classmethod
    def log(cls, message, type_):
        if cls.logger is None:
            if type_ == &#34;error&#34; or type_ == &#34;critical&#34;:
                if isinstance(message, BaseException):
                    raise message
                else:
                    raise ValueError(message)
            elif type_ == &#34;warning&#34;:
                warnings.warn(message)
            elif type_ != &#34;debug&#34;:
                print(message)
        else:
            getattr(cls.logger, type_)(message)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pdffactory.pdffactory.PdfFactory.SILENCED"><code class="name">var <span class="ident">SILENCED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.logger"><code class="name">var <span class="ident">logger</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pdffactory.pdffactory.PdfFactory.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>message, type_)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def log(cls, message, type_):
    if cls.logger is None:
        if type_ == &#34;error&#34; or type_ == &#34;critical&#34;:
            if isinstance(message, BaseException):
                raise message
            else:
                raise ValueError(message)
        elif type_ == &#34;warning&#34;:
            warnings.warn(message)
        elif type_ != &#34;debug&#34;:
            print(message)
    else:
        getattr(cls.logger, type_)(message)</code></pre>
</details>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.set_silenced"><code class="name flex">
<span>def <span class="ident">set_silenced</span></span>(<span>silenced: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>To not print anything (except errors)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def set_silenced(cls, silenced: bool) -&gt; None:
    &#34;&#34;&#34;To not print anything (except errors)&#34;&#34;&#34;
    cls.SILENCED = silenced</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pdffactory.pdffactory.PdfFactory.add_figure"><code class="name flex">
<span>def <span class="ident">add_figure</span></span>(<span>self, fig: <function figure at 0x7f0ea7633940>, update: bool = True, recreate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>To add a page containing a matplotlib.pyplot figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fig</code></strong> :&ensp;<code>plt.figure : the figure object to add</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>update</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, updates the file located at self.path. If False,
update must be done later by calling update() or by
calling any add_something() method with update=True.
Default True.</dd>
<dt><strong><code>recreate</code></strong> :&ensp;<code>bool :</code></dt>
<dd>If True, any file found at self.path will be overwritten.
Only valid if update is True.
Default False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_figure(self, fig: plt.figure, update: bool = True, recreate: bool = False) -&gt; None:
    &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

    Parameters
    ----------
    fig: plt.figure : the figure object to add
    update: bool
        If true, updates the file located at self.path. If False,
        update must be done later by calling update() or by
        calling any add_something() method with update=True.
        Default True.
    recreate: bool :
        If True, any file found at self.path will be overwritten.
        Only valid if update is True.
        Default False.
    &#34;&#34;&#34;

    if not isinstance(fig, plt.Figure):
        raise ValueError(f&#34;Only accepts matplotlib.figure.Figure object, not {type(fig)}&#34;)

    PdfFactory.log(&#34;Adding a figure&#34;, &#34;debug&#34;)
    pdf = pltpdf.PdfPages(self.path_tmp.name)
    pdf.savefig(fig, bbox_inches=&#34;tight&#34;)
    pdf.close()
    if update:
        # If recreate is specified, recreates the file.
        # If it is the first time that add_something() was called, also
        # recreated the file
        self.update(recreate or not self.recreated)
        self.recreated = True</code></pre>
</details>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.add_table"><code class="name flex">
<span>def <span class="ident">add_table</span></span>(<span>self, table: tablewriter.tablewriter.TableWriter, update: bool = True, recreate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>To add a page containing a matplotlib.pyplot figure.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>table</code></strong> :&ensp;<code>TableWriter : the table object to add</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>update</code></strong> :&ensp;<code>bool</code></dt>
<dd>If true, updates the file located at self.path. If False,
update must be done later by calling update() or by
calling any add_something() method with update=True.
Default True.</dd>
<dt><strong><code>recreate</code></strong> :&ensp;<code>bool :</code></dt>
<dd>If True, any file found at self.path will be overwritten.
Only valid if update is True.
Default False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_table(self, table: TableWriter, update: bool = True, recreate: bool = False) -&gt; None:
    &#34;&#34;&#34;To add a page containing a matplotlib.pyplot figure.

    Parameters
    ----------
    table: TableWriter : the table object to add
    update: bool
        If true, updates the file located at self.path. If False,
        update must be done later by calling update() or by
        calling any add_something() method with update=True.
        Default True.
    recreate: bool :
        If True, any file found at self.path will be overwritten.
        Only valid if update is True.
        Default False.
    &#34;&#34;&#34;

    if not isinstance(table, TableWriter):
        raise ValueError(f&#34;Only accepts TableWriter object, not {type(table)}&#34;)

    PdfFactory.log(&#34;Adding a table&#34;, &#34;debug&#34;)
    table.path = self.path_tmp.name
    table.compile(silenced=PdfFactory.SILENCED, clean_tex=True)
    if update:
        # If recreate is specified, recreates the file.
        # If it is the first time that add_something() was called, also
        # recreated the file
        self.update(recreate or not self.recreated)
        self.recreated = True</code></pre>
</details>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.get_pdf_pages"><code class="name flex">
<span>def <span class="ident">get_pdf_pages</span></span>(<span>self, path: Union[str, pathlib.Path, ForwardRef('TransparentPath')], out: PyPDF2.pdf.PdfFileWriter) ‑> Optional[<class 'BinaryIO'>]</span>
</code></dt>
<dd>
<div class="desc"><p>To get existing pages in a given pdf file.</p>
<p>Will raise an error if the file exists by failed to read.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[Path, TransparentPath, str] : The path to read pages from</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>out</code></strong> :&ensp;<code>PyPDF2.PdfFileWriter :</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>The object in which to store those pages</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[BinaryIO, None]</code></dt>
<dd>The opened file at path if successfully read, None if no
file were found.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pdf_pages(
    self, path: Union[Path, &#34;TransparentPath&#34;, str], out: PyPDF2.PdfFileWriter
) -&gt; Union[BinaryIO, None]:
    &#34;&#34;&#34;To get existing pages in a given pdf file.

    Will raise an error if the file exists by failed to read.

    Parameters
    ----------
    path: Union[Path, TransparentPath, str] : The path to read pages from
    out: PyPDF2.PdfFileWriter :
     The object in which to store those pages

    Returns
    -------
    Union[BinaryIO, None]
        The opened file at path if successfully read, None if no
        file were found.
    &#34;&#34;&#34;

    if type(path) == str:
        path = Path(path)
    PdfFactory.log(f&#34;  getting pdf pages from {path}&#34;, &#34;debug&#34;)
    if path.is_file():
        PdfFactory.log(f&#34;    found the file {path}&#34;, &#34;debug&#34;)
        try:
            f = open(path, &#34;rb&#34;)
            pdf = PyPDF2.PdfFileReader(f)
            for ipage in range(pdf.getNumPages()):
                out.addPage(pdf.getPage(ipage))
            return f
        except Exception as e:
            Path(self.path_tmp.name).unlink()
            raise e

    PdfFactory.log(f&#34;    did not find the file {path}&#34;, &#34;debug&#34;)
    return None</code></pre>
</details>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, recreate: bool = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the file located at self.path. Will overwrite any existing
file at self.path if recreate is True.</p>
<h2 id="parameters">Parameters</h2>
<p>recreate: bool : Overwrite any existing file at self.path if True.
Else, update it with the new pages.
Default False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, recreate: bool = False) -&gt; None:
    &#34;&#34;&#34;Updates the file located at self.path. Will overwrite any existing
    file at self.path if recreate is True.

    Parameters
    ----------
    recreate: bool : Overwrite any existing file at self.path if True.
        Else, update it with the new pages.
        Default False.
    &#34;&#34;&#34;

    output = PyPDF2.PdfFileWriter()

    f_old = None
    if not recreate:

        PdfFactory.log(f&#34;fetching old file {self.path}&#34;, &#34;debug&#34;)
        f_old = self.get_pdf_pages(self.path, output)

    PdfFactory.log(f&#34;fetching tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
    f_new = self.get_pdf_pages(Path(self.path_tmp.name, fs=&#34;local&#34;), output)

    if &#34;append&#34; in dir(self.path):
        with open(self.path.append(&#34;_&#34;), &#34;wb&#34;) as outputStream:
            output.write(outputStream)
    else:
        with open(str(self.path) + &#34;_&#34;, &#34;wb&#34;) as outputStream:
            output.write(outputStream)

    if f_old is not None:
        f_old.close()
    if f_new is not None:
        f_new.close()

    self.path_tmp.close()

    PdfFactory.log(f&#34;deleting tmp file {self.path_tmp.name}&#34;, &#34;debug&#34;)
    unlink_if_exists(Path(self.path_tmp.name, fs=&#34;local&#34;))
    if &#34;append&#34; in dir(self.path):
        self.path.append(&#34;_&#34;).mv(self.path)
    else:
        Path(str(self.path) + &#34;_&#34;).rename(self.path)</code></pre>
</details>
</dd>
<dt id="pdffactory.pdffactory.PdfFactory.will_recreate"><code class="name flex">
<span>def <span class="ident">will_recreate</span></span>(<span>self, b: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>If True (default behavior), previous file is overwriten. Else,
appends the new pages to it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>b</code></strong> :&ensp;<code>bool</code></dt>
<dd>Default True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def will_recreate(self, b: bool = True) -&gt; None:
    &#34;&#34;&#34;If True (default behavior), previous file is overwriten. Else,
    appends the new pages to it.

    Parameters
    ----------
    b: bool
        Default True
    &#34;&#34;&#34;
    self.recreated = not b</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pdffactory" href="index.html">pdffactory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pdffactory.pdffactory.unlink_if_exists" href="#pdffactory.pdffactory.unlink_if_exists">unlink_if_exists</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pdffactory.pdffactory.PdfFactory" href="#pdffactory.pdffactory.PdfFactory">PdfFactory</a></code></h4>
<ul class="two-column">
<li><code><a title="pdffactory.pdffactory.PdfFactory.SILENCED" href="#pdffactory.pdffactory.PdfFactory.SILENCED">SILENCED</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.add_figure" href="#pdffactory.pdffactory.PdfFactory.add_figure">add_figure</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.add_table" href="#pdffactory.pdffactory.PdfFactory.add_table">add_table</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.get_pdf_pages" href="#pdffactory.pdffactory.PdfFactory.get_pdf_pages">get_pdf_pages</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.log" href="#pdffactory.pdffactory.PdfFactory.log">log</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.logger" href="#pdffactory.pdffactory.PdfFactory.logger">logger</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.set_silenced" href="#pdffactory.pdffactory.PdfFactory.set_silenced">set_silenced</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.update" href="#pdffactory.pdffactory.PdfFactory.update">update</a></code></li>
<li><code><a title="pdffactory.pdffactory.PdfFactory.will_recreate" href="#pdffactory.pdffactory.PdfFactory.will_recreate">will_recreate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>